/*
Nango API

Nango API specs used to authorize & sync data with external APIs.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package nango

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type ApiActionTriggerPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	connectionId *string
	providerConfigKey *string
	actionTriggerPostRequest *ActionTriggerPostRequest
}

// The connection ID used to create the connection.
func (r ApiActionTriggerPostRequest) ConnectionId(connectionId string) ApiActionTriggerPostRequest {
	r.connectionId = &connectionId
	return r
}

// The integration ID used to create the connection (aka Unique Key).
func (r ApiActionTriggerPostRequest) ProviderConfigKey(providerConfigKey string) ApiActionTriggerPostRequest {
	r.providerConfigKey = &providerConfigKey
	return r
}

func (r ApiActionTriggerPostRequest) ActionTriggerPostRequest(actionTriggerPostRequest ActionTriggerPostRequest) ApiActionTriggerPostRequest {
	r.actionTriggerPostRequest = &actionTriggerPostRequest
	return r
}

func (r ApiActionTriggerPostRequest) Execute() (*ActionTriggerPost200Response, *http.Response, error) {
	return r.ApiService.ActionTriggerPostExecute(r)
}

/*
ActionTriggerPost Method for ActionTriggerPost

Triggers an action for a connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiActionTriggerPostRequest
*/
func (a *DefaultAPIService) ActionTriggerPost(ctx context.Context) ApiActionTriggerPostRequest {
	return ApiActionTriggerPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActionTriggerPost200Response
func (a *DefaultAPIService) ActionTriggerPostExecute(r ApiActionTriggerPostRequest) (*ActionTriggerPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionTriggerPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ActionTriggerPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/action/trigger"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.connectionId == nil {
		return localVarReturnValue, nil, reportError("connectionId is required and must be specified")
	}
	if r.providerConfigKey == nil {
		return localVarReturnValue, nil, reportError("providerConfigKey is required and must be specified")
	}
	if r.actionTriggerPostRequest == nil {
		return localVarReturnValue, nil, reportError("actionTriggerPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Connection-Id", r.connectionId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Provider-Config-Key", r.providerConfigKey, "")
	// body params
	localVarPostBody = r.actionTriggerPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ConfigPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConfigGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiConfigGetRequest) Execute() (*ConfigGet200Response, *http.Response, error) {
	return r.ApiService.ConfigGetExecute(r)
}

/*
ConfigGet Method for ConfigGet

Returns a list of integrations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConfigGetRequest
*/
func (a *DefaultAPIService) ConfigGet(ctx context.Context) ApiConfigGetRequest {
	return ApiConfigGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConfigGet200Response
func (a *DefaultAPIService) ConfigGetExecute(r ApiConfigGetRequest) (*ConfigGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConfigGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ConfigGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConfigPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	configPostRequest *ConfigPostRequest
}

func (r ApiConfigPostRequest) ConfigPostRequest(configPostRequest ConfigPostRequest) ApiConfigPostRequest {
	r.configPostRequest = &configPostRequest
	return r
}

func (r ApiConfigPostRequest) Execute() (*ConfigPut200Response, *http.Response, error) {
	return r.ApiService.ConfigPostExecute(r)
}

/*
ConfigPost Method for ConfigPost

Create a new integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConfigPostRequest
*/
func (a *DefaultAPIService) ConfigPost(ctx context.Context) ApiConfigPostRequest {
	return ApiConfigPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConfigPut200Response
func (a *DefaultAPIService) ConfigPostExecute(r ApiConfigPostRequest) (*ConfigPut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConfigPut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ConfigPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configPostRequest == nil {
		return localVarReturnValue, nil, reportError("configPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ConfigPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConfigProviderConfigKeyDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	providerConfigKey string
}

func (r ApiConfigProviderConfigKeyDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConfigProviderConfigKeyDeleteExecute(r)
}

/*
ConfigProviderConfigKeyDelete Method for ConfigProviderConfigKeyDelete

Deletes a specific integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param providerConfigKey The integration ID that you created in Nango.
 @return ApiConfigProviderConfigKeyDeleteRequest
*/
func (a *DefaultAPIService) ConfigProviderConfigKeyDelete(ctx context.Context, providerConfigKey string) ApiConfigProviderConfigKeyDeleteRequest {
	return ApiConfigProviderConfigKeyDeleteRequest{
		ApiService: a,
		ctx: ctx,
		providerConfigKey: providerConfigKey,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ConfigProviderConfigKeyDeleteExecute(r ApiConfigProviderConfigKeyDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ConfigProviderConfigKeyDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/{providerConfigKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"providerConfigKey"+"}", url.PathEscape(parameterValueToString(r.providerConfigKey, "providerConfigKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ConfigPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ConfigPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConfigProviderConfigKeyGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	providerConfigKey string
	includeCreds *bool
}

// If true, the response will contain the client ID, secret, scopes, auth_mode and app link - if applicable. include_creds is false by default.
func (r ApiConfigProviderConfigKeyGetRequest) IncludeCreds(includeCreds bool) ApiConfigProviderConfigKeyGetRequest {
	r.includeCreds = &includeCreds
	return r
}

func (r ApiConfigProviderConfigKeyGetRequest) Execute() (*ConfigProviderConfigKeyGet200Response, *http.Response, error) {
	return r.ApiService.ConfigProviderConfigKeyGetExecute(r)
}

/*
ConfigProviderConfigKeyGet Method for ConfigProviderConfigKeyGet

Returns a specific integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param providerConfigKey The integration ID that you created in Nango.
 @return ApiConfigProviderConfigKeyGetRequest
*/
func (a *DefaultAPIService) ConfigProviderConfigKeyGet(ctx context.Context, providerConfigKey string) ApiConfigProviderConfigKeyGetRequest {
	return ApiConfigProviderConfigKeyGetRequest{
		ApiService: a,
		ctx: ctx,
		providerConfigKey: providerConfigKey,
	}
}

// Execute executes the request
//  @return ConfigProviderConfigKeyGet200Response
func (a *DefaultAPIService) ConfigProviderConfigKeyGetExecute(r ApiConfigProviderConfigKeyGetRequest) (*ConfigProviderConfigKeyGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConfigProviderConfigKeyGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ConfigProviderConfigKeyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/{providerConfigKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"providerConfigKey"+"}", url.PathEscape(parameterValueToString(r.providerConfigKey, "providerConfigKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeCreds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_creds", r.includeCreds, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ConfigPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ConfigPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConfigPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	configPutRequest *ConfigPutRequest
}

func (r ApiConfigPutRequest) ConfigPutRequest(configPutRequest ConfigPutRequest) ApiConfigPutRequest {
	r.configPutRequest = &configPutRequest
	return r
}

func (r ApiConfigPutRequest) Execute() (*ConfigPut200Response, *http.Response, error) {
	return r.ApiService.ConfigPutExecute(r)
}

/*
ConfigPut Method for ConfigPut

Edits an integration (only for OAuth APIs)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConfigPutRequest
*/
func (a *DefaultAPIService) ConfigPut(ctx context.Context) ApiConfigPutRequest {
	return ApiConfigPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConfigPut200Response
func (a *DefaultAPIService) ConfigPutExecute(r ApiConfigPutRequest) (*ConfigPut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConfigPut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ConfigPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configPutRequest == nil {
		return localVarReturnValue, nil, reportError("configPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ConfigPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ConfigPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionConnectionIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	connectionId string
	providerConfigKey *string
}

// The integration ID used to create the connection (aka Unique Key).
func (r ApiConnectionConnectionIdDeleteRequest) ProviderConfigKey(providerConfigKey string) ApiConnectionConnectionIdDeleteRequest {
	r.providerConfigKey = &providerConfigKey
	return r
}

func (r ApiConnectionConnectionIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConnectionConnectionIdDeleteExecute(r)
}

/*
ConnectionConnectionIdDelete Method for ConnectionConnectionIdDelete

Deletes a specific connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionId The connection ID used to create the connection.
 @return ApiConnectionConnectionIdDeleteRequest
*/
func (a *DefaultAPIService) ConnectionConnectionIdDelete(ctx context.Context, connectionId string) ApiConnectionConnectionIdDeleteRequest {
	return ApiConnectionConnectionIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		connectionId: connectionId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ConnectionConnectionIdDeleteExecute(r ApiConnectionConnectionIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ConnectionConnectionIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connection/{connectionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionId"+"}", url.PathEscape(parameterValueToString(r.connectionId, "connectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerConfigKey == nil {
		return nil, reportError("providerConfigKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "provider_config_key", r.providerConfigKey, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ConfigPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ConfigPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConnectionConnectionIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	connectionId string
	providerConfigKey *string
	forceRefresh *bool
	refreshToken *bool
}

// The integration ID used to create the connection (aka Unique Key).
func (r ApiConnectionConnectionIdGetRequest) ProviderConfigKey(providerConfigKey string) ApiConnectionConnectionIdGetRequest {
	r.providerConfigKey = &providerConfigKey
	return r
}

// If true, Nango will attempt to refresh the access access token regardless of its expiration status (false by default).
func (r ApiConnectionConnectionIdGetRequest) ForceRefresh(forceRefresh bool) ApiConnectionConnectionIdGetRequest {
	r.forceRefresh = &forceRefresh
	return r
}

// If true, return the refresh token as part of the response (false by default).
func (r ApiConnectionConnectionIdGetRequest) RefreshToken(refreshToken bool) ApiConnectionConnectionIdGetRequest {
	r.refreshToken = &refreshToken
	return r
}

func (r ApiConnectionConnectionIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConnectionConnectionIdGetExecute(r)
}

/*
ConnectionConnectionIdGet Method for ConnectionConnectionIdGet

Returns a specific connection with credentials

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionId The connection ID used to create the connection.
 @return ApiConnectionConnectionIdGetRequest
*/
func (a *DefaultAPIService) ConnectionConnectionIdGet(ctx context.Context, connectionId string) ApiConnectionConnectionIdGetRequest {
	return ApiConnectionConnectionIdGetRequest{
		ApiService: a,
		ctx: ctx,
		connectionId: connectionId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ConnectionConnectionIdGetExecute(r ApiConnectionConnectionIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ConnectionConnectionIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connection/{connectionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionId"+"}", url.PathEscape(parameterValueToString(r.connectionId, "connectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerConfigKey == nil {
		return nil, reportError("providerConfigKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "provider_config_key", r.providerConfigKey, "")
	if r.forceRefresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force_refresh", r.forceRefresh, "")
	}
	if r.refreshToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh_token", r.refreshToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ConfigPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ConfigPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConnectionConnectionIdMetadataPatchRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	connectionId string
	providerConfigKey *string
	body *map[string]interface{}
}

// The integration ID used to create the connection (aka Unique Key).
func (r ApiConnectionConnectionIdMetadataPatchRequest) ProviderConfigKey(providerConfigKey string) ApiConnectionConnectionIdMetadataPatchRequest {
	r.providerConfigKey = &providerConfigKey
	return r
}

func (r ApiConnectionConnectionIdMetadataPatchRequest) Body(body map[string]interface{}) ApiConnectionConnectionIdMetadataPatchRequest {
	r.body = &body
	return r
}

func (r ApiConnectionConnectionIdMetadataPatchRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ConnectionConnectionIdMetadataPatchExecute(r)
}

/*
ConnectionConnectionIdMetadataPatch Method for ConnectionConnectionIdMetadataPatch

Edit custom metadata for the connection (only overrides specified properties, not the entire metadata).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionId The connection ID used to create the connection.
 @return ApiConnectionConnectionIdMetadataPatchRequest
*/
func (a *DefaultAPIService) ConnectionConnectionIdMetadataPatch(ctx context.Context, connectionId string) ApiConnectionConnectionIdMetadataPatchRequest {
	return ApiConnectionConnectionIdMetadataPatchRequest{
		ApiService: a,
		ctx: ctx,
		connectionId: connectionId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) ConnectionConnectionIdMetadataPatchExecute(r ApiConnectionConnectionIdMetadataPatchRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ConnectionConnectionIdMetadataPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connection/{connectionId}/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionId"+"}", url.PathEscape(parameterValueToString(r.connectionId, "connectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerConfigKey == nil {
		return localVarReturnValue, nil, reportError("providerConfigKey is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Provider-Config-Key", r.providerConfigKey, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ConfigPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionConnectionIdMetadataPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	connectionId string
	providerConfigKey *string
	body *map[string]interface{}
}

// The integration ID used to create the connection (aka Unique Key).
func (r ApiConnectionConnectionIdMetadataPostRequest) ProviderConfigKey(providerConfigKey string) ApiConnectionConnectionIdMetadataPostRequest {
	r.providerConfigKey = &providerConfigKey
	return r
}

func (r ApiConnectionConnectionIdMetadataPostRequest) Body(body map[string]interface{}) ApiConnectionConnectionIdMetadataPostRequest {
	r.body = &body
	return r
}

func (r ApiConnectionConnectionIdMetadataPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConnectionConnectionIdMetadataPostExecute(r)
}

/*
ConnectionConnectionIdMetadataPost Method for ConnectionConnectionIdMetadataPost

Set custom metadata for the connection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionId The connection ID used to create the connection.
 @return ApiConnectionConnectionIdMetadataPostRequest
*/
func (a *DefaultAPIService) ConnectionConnectionIdMetadataPost(ctx context.Context, connectionId string) ApiConnectionConnectionIdMetadataPostRequest {
	return ApiConnectionConnectionIdMetadataPostRequest{
		ApiService: a,
		ctx: ctx,
		connectionId: connectionId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ConnectionConnectionIdMetadataPostExecute(r ApiConnectionConnectionIdMetadataPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ConnectionConnectionIdMetadataPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connection/{connectionId}/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionId"+"}", url.PathEscape(parameterValueToString(r.connectionId, "connectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerConfigKey == nil {
		return nil, reportError("providerConfigKey is required and must be specified")
	}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Provider-Config-Key", r.providerConfigKey, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ConfigPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConnectionGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	connectionId *string
}

// Filter the list of connections based on this connection ID.
func (r ApiConnectionGetRequest) ConnectionId(connectionId string) ApiConnectionGetRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiConnectionGetRequest) Execute() (*ConnectionGet200Response, *http.Response, error) {
	return r.ApiService.ConnectionGetExecute(r)
}

/*
ConnectionGet Method for ConnectionGet

Returns a list of connections without credentials

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConnectionGetRequest
*/
func (a *DefaultAPIService) ConnectionGet(ctx context.Context) ApiConnectionGetRequest {
	return ApiConnectionGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConnectionGet200Response
func (a *DefaultAPIService) ConnectionGetExecute(r ApiConnectionGetRequest) (*ConnectionGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectionGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ConnectionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connection"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionMetadataPatchRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	connectionMetadataPatchRequest *ConnectionMetadataPatchRequest
}

func (r ApiConnectionMetadataPatchRequest) ConnectionMetadataPatchRequest(connectionMetadataPatchRequest ConnectionMetadataPatchRequest) ApiConnectionMetadataPatchRequest {
	r.connectionMetadataPatchRequest = &connectionMetadataPatchRequest
	return r
}

func (r ApiConnectionMetadataPatchRequest) Execute() (*ConnectionMetadataPatch200Response, *http.Response, error) {
	return r.ApiService.ConnectionMetadataPatchExecute(r)
}

/*
ConnectionMetadataPatch Method for ConnectionMetadataPatch

Edit custom metadata for the connection or connections (only overrides specified properties, not the entire metadata). If updating multiple connections pass in an array of connection ids instead of a string.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConnectionMetadataPatchRequest
*/
func (a *DefaultAPIService) ConnectionMetadataPatch(ctx context.Context) ApiConnectionMetadataPatchRequest {
	return ApiConnectionMetadataPatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConnectionMetadataPatch200Response
func (a *DefaultAPIService) ConnectionMetadataPatchExecute(r ApiConnectionMetadataPatchRequest) (*ConnectionMetadataPatch200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectionMetadataPatch200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ConnectionMetadataPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connection/metadata"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.connectionMetadataPatchRequest == nil {
		return localVarReturnValue, nil, reportError("connectionMetadataPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.connectionMetadataPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ConfigPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionMetadataPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	connectionMetadataPostRequest *ConnectionMetadataPostRequest
}

func (r ApiConnectionMetadataPostRequest) ConnectionMetadataPostRequest(connectionMetadataPostRequest ConnectionMetadataPostRequest) ApiConnectionMetadataPostRequest {
	r.connectionMetadataPostRequest = &connectionMetadataPostRequest
	return r
}

func (r ApiConnectionMetadataPostRequest) Execute() (*ConnectionMetadataPost201Response, *http.Response, error) {
	return r.ApiService.ConnectionMetadataPostExecute(r)
}

/*
ConnectionMetadataPost Method for ConnectionMetadataPost

Set custom metadata for the connection or connections. If updating multiple connections pass in an array of connection ids instead of a string.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConnectionMetadataPostRequest
*/
func (a *DefaultAPIService) ConnectionMetadataPost(ctx context.Context) ApiConnectionMetadataPostRequest {
	return ApiConnectionMetadataPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConnectionMetadataPost201Response
func (a *DefaultAPIService) ConnectionMetadataPostExecute(r ApiConnectionMetadataPostRequest) (*ConnectionMetadataPost201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectionMetadataPost201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ConnectionMetadataPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connection/metadata"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.connectionMetadataPostRequest == nil {
		return localVarReturnValue, nil, reportError("connectionMetadataPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.connectionMetadataPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ConfigPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	connectionPostRequest *ConnectionPostRequest
}

func (r ApiConnectionPostRequest) ConnectionPostRequest(connectionPostRequest ConnectionPostRequest) ApiConnectionPostRequest {
	r.connectionPostRequest = &connectionPostRequest
	return r
}

func (r ApiConnectionPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConnectionPostExecute(r)
}

/*
ConnectionPost Method for ConnectionPost

Adds a connection for which you already have credentials.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConnectionPostRequest
*/
func (a *DefaultAPIService) ConnectionPost(ctx context.Context) ApiConnectionPostRequest {
	return ApiConnectionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ConnectionPostExecute(r ApiConnectionPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ConnectionPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connection"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.connectionPostRequest == nil {
		return nil, reportError("connectionPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.connectionPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ConfigPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentVariablesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiEnvironmentVariablesGetRequest) Execute() ([]EnvironmentVariablesGet200ResponseInner, *http.Response, error) {
	return r.ApiService.EnvironmentVariablesGetExecute(r)
}

/*
EnvironmentVariablesGet Method for EnvironmentVariablesGet

Retrieve the environment variables as added in the Nango dashboard

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEnvironmentVariablesGetRequest
*/
func (a *DefaultAPIService) EnvironmentVariablesGet(ctx context.Context) ApiEnvironmentVariablesGetRequest {
	return ApiEnvironmentVariablesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []EnvironmentVariablesGet200ResponseInner
func (a *DefaultAPIService) EnvironmentVariablesGetExecute(r ApiEnvironmentVariablesGetRequest) ([]EnvironmentVariablesGet200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []EnvironmentVariablesGet200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EnvironmentVariablesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environment-variables"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProxyAnyPathDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	anyPath string
	aNYQUERYPARAMS *string
	connectionId *string
	providerConfigKey *string
	retries *string
	baseUrlOverride *string
	decompress *string
	nangoProxyANYHEADER *string
}

func (r ApiProxyAnyPathDeleteRequest) ANYQUERYPARAMS(aNYQUERYPARAMS string) ApiProxyAnyPathDeleteRequest {
	r.aNYQUERYPARAMS = &aNYQUERYPARAMS
	return r
}

// The connection ID used to create the connection.
func (r ApiProxyAnyPathDeleteRequest) ConnectionId(connectionId string) ApiProxyAnyPathDeleteRequest {
	r.connectionId = &connectionId
	return r
}

// The integration ID used to create the connection (aka Unique Key).
func (r ApiProxyAnyPathDeleteRequest) ProviderConfigKey(providerConfigKey string) ApiProxyAnyPathDeleteRequest {
	r.providerConfigKey = &providerConfigKey
	return r
}

// The number of retries in case of failure (with exponential back-off). Optional, default 0.
func (r ApiProxyAnyPathDeleteRequest) Retries(retries string) ApiProxyAnyPathDeleteRequest {
	r.retries = &retries
	return r
}

// Provide an API base URL when the base API is not listed in the providers.yaml or it needs to be overridden. Optional
func (r ApiProxyAnyPathDeleteRequest) BaseUrlOverride(baseUrlOverride string) ApiProxyAnyPathDeleteRequest {
	r.baseUrlOverride = &baseUrlOverride
	return r
}

// Override the decompress option when making requests. Optional, defaults to false
func (r ApiProxyAnyPathDeleteRequest) Decompress(decompress string) ApiProxyAnyPathDeleteRequest {
	r.decompress = &decompress
	return r
}

// Any other headers you send are passed on to the external API
func (r ApiProxyAnyPathDeleteRequest) NangoProxyANYHEADER(nangoProxyANYHEADER string) ApiProxyAnyPathDeleteRequest {
	r.nangoProxyANYHEADER = &nangoProxyANYHEADER
	return r
}

func (r ApiProxyAnyPathDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProxyAnyPathDeleteExecute(r)
}

/*
ProxyAnyPathDelete Method for ProxyAnyPathDelete

Make a DELETE request with the Proxy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param anyPath
 @return ApiProxyAnyPathDeleteRequest
*/
func (a *DefaultAPIService) ProxyAnyPathDelete(ctx context.Context, anyPath string) ApiProxyAnyPathDeleteRequest {
	return ApiProxyAnyPathDeleteRequest{
		ApiService: a,
		ctx: ctx,
		anyPath: anyPath,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ProxyAnyPathDeleteExecute(r ApiProxyAnyPathDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ProxyAnyPathDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/proxy/{anyPath}"
	localVarPath = strings.Replace(localVarPath, "{"+"anyPath"+"}", url.PathEscape(parameterValueToString(r.anyPath, "anyPath")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aNYQUERYPARAMS == nil {
		return nil, reportError("aNYQUERYPARAMS is required and must be specified")
	}
	if r.connectionId == nil {
		return nil, reportError("connectionId is required and must be specified")
	}
	if r.providerConfigKey == nil {
		return nil, reportError("providerConfigKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "$ANY_QUERY_PARAMS", r.aNYQUERYPARAMS, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Connection-Id", r.connectionId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Provider-Config-Key", r.providerConfigKey, "")
	if r.retries != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Retries", r.retries, "")
	}
	if r.baseUrlOverride != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Base-Url-Override", r.baseUrlOverride, "")
	}
	if r.decompress != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Decompress", r.decompress, "")
	}
	if r.nangoProxyANYHEADER != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "nango-proxy-$ANY_HEADER", r.nangoProxyANYHEADER, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProxyAnyPathGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	anyPath string
	aNYQUERYPARAMS *string
	connectionId *string
	providerConfigKey *string
	retries *string
	retryOn *string
	baseUrlOverride *string
	decompress *string
	nangoProxyANYHEADER *string
}

func (r ApiProxyAnyPathGetRequest) ANYQUERYPARAMS(aNYQUERYPARAMS string) ApiProxyAnyPathGetRequest {
	r.aNYQUERYPARAMS = &aNYQUERYPARAMS
	return r
}

// The connection ID used to create the connection.
func (r ApiProxyAnyPathGetRequest) ConnectionId(connectionId string) ApiProxyAnyPathGetRequest {
	r.connectionId = &connectionId
	return r
}

// The integration ID used to create the connection (aka Unique Key).
func (r ApiProxyAnyPathGetRequest) ProviderConfigKey(providerConfigKey string) ApiProxyAnyPathGetRequest {
	r.providerConfigKey = &providerConfigKey
	return r
}

// The number of retries in case of failure (with exponential back-off). Optional, default 0.
func (r ApiProxyAnyPathGetRequest) Retries(retries string) ApiProxyAnyPathGetRequest {
	r.retries = &retries
	return r
}

// Comma separated status codes to explicitly retry on in addition to the default 5xx and 429.
func (r ApiProxyAnyPathGetRequest) RetryOn(retryOn string) ApiProxyAnyPathGetRequest {
	r.retryOn = &retryOn
	return r
}

// Provide an API base URL when the base API is not listed in the providers.yaml or it needs to be overridden. Optional
func (r ApiProxyAnyPathGetRequest) BaseUrlOverride(baseUrlOverride string) ApiProxyAnyPathGetRequest {
	r.baseUrlOverride = &baseUrlOverride
	return r
}

// Override the decompress option when making requests. Optional, defaults to false
func (r ApiProxyAnyPathGetRequest) Decompress(decompress string) ApiProxyAnyPathGetRequest {
	r.decompress = &decompress
	return r
}

// Any other headers you send are passed on to the external API
func (r ApiProxyAnyPathGetRequest) NangoProxyANYHEADER(nangoProxyANYHEADER string) ApiProxyAnyPathGetRequest {
	r.nangoProxyANYHEADER = &nangoProxyANYHEADER
	return r
}

func (r ApiProxyAnyPathGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProxyAnyPathGetExecute(r)
}

/*
ProxyAnyPathGet Method for ProxyAnyPathGet

Make a GET request with the Proxy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param anyPath
 @return ApiProxyAnyPathGetRequest
*/
func (a *DefaultAPIService) ProxyAnyPathGet(ctx context.Context, anyPath string) ApiProxyAnyPathGetRequest {
	return ApiProxyAnyPathGetRequest{
		ApiService: a,
		ctx: ctx,
		anyPath: anyPath,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ProxyAnyPathGetExecute(r ApiProxyAnyPathGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ProxyAnyPathGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/proxy/{anyPath}"
	localVarPath = strings.Replace(localVarPath, "{"+"anyPath"+"}", url.PathEscape(parameterValueToString(r.anyPath, "anyPath")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aNYQUERYPARAMS == nil {
		return nil, reportError("aNYQUERYPARAMS is required and must be specified")
	}
	if r.connectionId == nil {
		return nil, reportError("connectionId is required and must be specified")
	}
	if r.providerConfigKey == nil {
		return nil, reportError("providerConfigKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "$ANY_QUERY_PARAMS", r.aNYQUERYPARAMS, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Connection-Id", r.connectionId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Provider-Config-Key", r.providerConfigKey, "")
	if r.retries != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Retries", r.retries, "")
	}
	if r.retryOn != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Retry On", r.retryOn, "")
	}
	if r.baseUrlOverride != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Base-Url-Override", r.baseUrlOverride, "")
	}
	if r.decompress != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Decompress", r.decompress, "")
	}
	if r.nangoProxyANYHEADER != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "nango-proxy-$ANY_HEADER", r.nangoProxyANYHEADER, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProxyAnyPathPatchRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	anyPath string
	connectionId *string
	providerConfigKey *string
	retries *string
	baseUrlOverride *string
	decompress *string
	nangoProxyANYHEADER *string
	proxyAnyPathPutRequest *ProxyAnyPathPutRequest
}

// The connection ID used to create the connection.
func (r ApiProxyAnyPathPatchRequest) ConnectionId(connectionId string) ApiProxyAnyPathPatchRequest {
	r.connectionId = &connectionId
	return r
}

// The integration ID used to create the connection (aka Unique Key).
func (r ApiProxyAnyPathPatchRequest) ProviderConfigKey(providerConfigKey string) ApiProxyAnyPathPatchRequest {
	r.providerConfigKey = &providerConfigKey
	return r
}

// The number of retries in case of failure (with exponential back-off). Optional, default 0.
func (r ApiProxyAnyPathPatchRequest) Retries(retries string) ApiProxyAnyPathPatchRequest {
	r.retries = &retries
	return r
}

// Provide an API base URL when the base API is not listed in the providers.yaml or it needs to be overridden. Optional
func (r ApiProxyAnyPathPatchRequest) BaseUrlOverride(baseUrlOverride string) ApiProxyAnyPathPatchRequest {
	r.baseUrlOverride = &baseUrlOverride
	return r
}

// Override the decompress option when making requests. Optional, defaults to false
func (r ApiProxyAnyPathPatchRequest) Decompress(decompress string) ApiProxyAnyPathPatchRequest {
	r.decompress = &decompress
	return r
}

// Any other headers you send are passed on to the external API
func (r ApiProxyAnyPathPatchRequest) NangoProxyANYHEADER(nangoProxyANYHEADER string) ApiProxyAnyPathPatchRequest {
	r.nangoProxyANYHEADER = &nangoProxyANYHEADER
	return r
}

func (r ApiProxyAnyPathPatchRequest) ProxyAnyPathPutRequest(proxyAnyPathPutRequest ProxyAnyPathPutRequest) ApiProxyAnyPathPatchRequest {
	r.proxyAnyPathPutRequest = &proxyAnyPathPutRequest
	return r
}

func (r ApiProxyAnyPathPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProxyAnyPathPatchExecute(r)
}

/*
ProxyAnyPathPatch Method for ProxyAnyPathPatch

Make a PATCH request with the Proxy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param anyPath
 @return ApiProxyAnyPathPatchRequest
*/
func (a *DefaultAPIService) ProxyAnyPathPatch(ctx context.Context, anyPath string) ApiProxyAnyPathPatchRequest {
	return ApiProxyAnyPathPatchRequest{
		ApiService: a,
		ctx: ctx,
		anyPath: anyPath,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ProxyAnyPathPatchExecute(r ApiProxyAnyPathPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ProxyAnyPathPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/proxy/{anyPath}"
	localVarPath = strings.Replace(localVarPath, "{"+"anyPath"+"}", url.PathEscape(parameterValueToString(r.anyPath, "anyPath")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.connectionId == nil {
		return nil, reportError("connectionId is required and must be specified")
	}
	if r.providerConfigKey == nil {
		return nil, reportError("providerConfigKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Connection-Id", r.connectionId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Provider-Config-Key", r.providerConfigKey, "")
	if r.retries != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Retries", r.retries, "")
	}
	if r.baseUrlOverride != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Base-Url-Override", r.baseUrlOverride, "")
	}
	if r.decompress != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Decompress", r.decompress, "")
	}
	if r.nangoProxyANYHEADER != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "nango-proxy-$ANY_HEADER", r.nangoProxyANYHEADER, "")
	}
	// body params
	localVarPostBody = r.proxyAnyPathPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProxyAnyPathPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	anyPath string
	connectionId *string
	providerConfigKey *string
	retries *string
	baseUrlOverride *string
	decompress *string
	nangoProxyANYHEADER *string
	proxyAnyPathPutRequest *ProxyAnyPathPutRequest
}

// The connection ID used to create the connection.
func (r ApiProxyAnyPathPostRequest) ConnectionId(connectionId string) ApiProxyAnyPathPostRequest {
	r.connectionId = &connectionId
	return r
}

// The integration ID used to create the connection (aka Unique Key).
func (r ApiProxyAnyPathPostRequest) ProviderConfigKey(providerConfigKey string) ApiProxyAnyPathPostRequest {
	r.providerConfigKey = &providerConfigKey
	return r
}

// The number of retries in case of failure (with exponential back-off). Optional, default 0.
func (r ApiProxyAnyPathPostRequest) Retries(retries string) ApiProxyAnyPathPostRequest {
	r.retries = &retries
	return r
}

// Provide an API base URL when the base API is not listed in the providers.yaml or it needs to be overridden. Optional
func (r ApiProxyAnyPathPostRequest) BaseUrlOverride(baseUrlOverride string) ApiProxyAnyPathPostRequest {
	r.baseUrlOverride = &baseUrlOverride
	return r
}

// Override the decompress option when making requests. Optional, defaults to false
func (r ApiProxyAnyPathPostRequest) Decompress(decompress string) ApiProxyAnyPathPostRequest {
	r.decompress = &decompress
	return r
}

// Any other headers you send are passed on to the external API
func (r ApiProxyAnyPathPostRequest) NangoProxyANYHEADER(nangoProxyANYHEADER string) ApiProxyAnyPathPostRequest {
	r.nangoProxyANYHEADER = &nangoProxyANYHEADER
	return r
}

func (r ApiProxyAnyPathPostRequest) ProxyAnyPathPutRequest(proxyAnyPathPutRequest ProxyAnyPathPutRequest) ApiProxyAnyPathPostRequest {
	r.proxyAnyPathPutRequest = &proxyAnyPathPutRequest
	return r
}

func (r ApiProxyAnyPathPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProxyAnyPathPostExecute(r)
}

/*
ProxyAnyPathPost Method for ProxyAnyPathPost

Make a POST request with the Proxy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param anyPath
 @return ApiProxyAnyPathPostRequest
*/
func (a *DefaultAPIService) ProxyAnyPathPost(ctx context.Context, anyPath string) ApiProxyAnyPathPostRequest {
	return ApiProxyAnyPathPostRequest{
		ApiService: a,
		ctx: ctx,
		anyPath: anyPath,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ProxyAnyPathPostExecute(r ApiProxyAnyPathPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ProxyAnyPathPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/proxy/{anyPath}"
	localVarPath = strings.Replace(localVarPath, "{"+"anyPath"+"}", url.PathEscape(parameterValueToString(r.anyPath, "anyPath")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.connectionId == nil {
		return nil, reportError("connectionId is required and must be specified")
	}
	if r.providerConfigKey == nil {
		return nil, reportError("providerConfigKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Connection-Id", r.connectionId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Provider-Config-Key", r.providerConfigKey, "")
	if r.retries != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Retries", r.retries, "")
	}
	if r.baseUrlOverride != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Base-Url-Override", r.baseUrlOverride, "")
	}
	if r.decompress != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Decompress", r.decompress, "")
	}
	if r.nangoProxyANYHEADER != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "nango-proxy-$ANY_HEADER", r.nangoProxyANYHEADER, "")
	}
	// body params
	localVarPostBody = r.proxyAnyPathPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProxyAnyPathPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	anyPath string
	connectionId *string
	providerConfigKey *string
	retries *string
	baseUrlOverride *string
	decompress *string
	nangoProxyANYHEADER *string
	proxyAnyPathPutRequest *ProxyAnyPathPutRequest
}

// The connection ID used to create the connection.
func (r ApiProxyAnyPathPutRequest) ConnectionId(connectionId string) ApiProxyAnyPathPutRequest {
	r.connectionId = &connectionId
	return r
}

// The integration ID used to create the connection (aka Unique Key).
func (r ApiProxyAnyPathPutRequest) ProviderConfigKey(providerConfigKey string) ApiProxyAnyPathPutRequest {
	r.providerConfigKey = &providerConfigKey
	return r
}

// The number of retries in case of failure (with exponential back-off). Optional, default 0.
func (r ApiProxyAnyPathPutRequest) Retries(retries string) ApiProxyAnyPathPutRequest {
	r.retries = &retries
	return r
}

// Provide an API base URL when the base API is not listed in the providers.yaml or it needs to be overridden. Optional
func (r ApiProxyAnyPathPutRequest) BaseUrlOverride(baseUrlOverride string) ApiProxyAnyPathPutRequest {
	r.baseUrlOverride = &baseUrlOverride
	return r
}

// Override the decompress option when making requests. Optional, defaults to false
func (r ApiProxyAnyPathPutRequest) Decompress(decompress string) ApiProxyAnyPathPutRequest {
	r.decompress = &decompress
	return r
}

// Any other headers you send are passed on to the external API
func (r ApiProxyAnyPathPutRequest) NangoProxyANYHEADER(nangoProxyANYHEADER string) ApiProxyAnyPathPutRequest {
	r.nangoProxyANYHEADER = &nangoProxyANYHEADER
	return r
}

func (r ApiProxyAnyPathPutRequest) ProxyAnyPathPutRequest(proxyAnyPathPutRequest ProxyAnyPathPutRequest) ApiProxyAnyPathPutRequest {
	r.proxyAnyPathPutRequest = &proxyAnyPathPutRequest
	return r
}

func (r ApiProxyAnyPathPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProxyAnyPathPutExecute(r)
}

/*
ProxyAnyPathPut Method for ProxyAnyPathPut

Make a PUT request with the Proxy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param anyPath
 @return ApiProxyAnyPathPutRequest
*/
func (a *DefaultAPIService) ProxyAnyPathPut(ctx context.Context, anyPath string) ApiProxyAnyPathPutRequest {
	return ApiProxyAnyPathPutRequest{
		ApiService: a,
		ctx: ctx,
		anyPath: anyPath,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ProxyAnyPathPutExecute(r ApiProxyAnyPathPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ProxyAnyPathPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/proxy/{anyPath}"
	localVarPath = strings.Replace(localVarPath, "{"+"anyPath"+"}", url.PathEscape(parameterValueToString(r.anyPath, "anyPath")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.connectionId == nil {
		return nil, reportError("connectionId is required and must be specified")
	}
	if r.providerConfigKey == nil {
		return nil, reportError("providerConfigKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Connection-Id", r.connectionId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Provider-Config-Key", r.providerConfigKey, "")
	if r.retries != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Retries", r.retries, "")
	}
	if r.baseUrlOverride != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Base-Url-Override", r.baseUrlOverride, "")
	}
	if r.decompress != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Decompress", r.decompress, "")
	}
	if r.nangoProxyANYHEADER != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "nango-proxy-$ANY_HEADER", r.nangoProxyANYHEADER, "")
	}
	// body params
	localVarPostBody = r.proxyAnyPathPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRecordsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	model *string
	connectionId *string
	providerConfigKey *string
	cursor *string
	limit *int32
	filter *string
	modifiedAfter *string
	deltaDeprecated *string
}

// The data model to fetch
func (r ApiRecordsGetRequest) Model(model string) ApiRecordsGetRequest {
	r.model = &model
	return r
}

// The connection ID used to create the connection.
func (r ApiRecordsGetRequest) ConnectionId(connectionId string) ApiRecordsGetRequest {
	r.connectionId = &connectionId
	return r
}

// The integration ID used to create the connection (aka Unique Key).
func (r ApiRecordsGetRequest) ProviderConfigKey(providerConfigKey string) ApiRecordsGetRequest {
	r.providerConfigKey = &providerConfigKey
	return r
}

// Each record from this method comes with a synchronization cursor in &#x60;_nango_metadata.cursor&#x60;. Save the last fetched record&#39;s cursor to track how far you&#39;ve synced. By providing the cursor to this endpoint, you&#39;ll continue syncing from where you left off, receiving only post-cursor changes. This same cursor is used to paginate through the results of this endpoint. 
func (r ApiRecordsGetRequest) Cursor(cursor string) ApiRecordsGetRequest {
	r.cursor = &cursor
	return r
}

// The maximum number of records to return. Defaults to 100.
func (r ApiRecordsGetRequest) Limit(limit int32) ApiRecordsGetRequest {
	r.limit = &limit
	return r
}

// Filter to only show results that have been added or updated or deleted.
func (r ApiRecordsGetRequest) Filter(filter string) ApiRecordsGetRequest {
	r.filter = &filter
	return r
}

// Timestamp, e.g. 2023-05-31T11:46:13.390Z. If passed only records modified after this timestamp are returned, otherwise all records are returned.
func (r ApiRecordsGetRequest) ModifiedAfter(modifiedAfter string) ApiRecordsGetRequest {
	r.modifiedAfter = &modifiedAfter
	return r
}

// DEPRECATED (use modified_after) Timestamp, e.g. 2023-05-31T11:46:13.390Z. If passed, only records modified after this timestamp are returned, otherwise all records are returned.
func (r ApiRecordsGetRequest) DeltaDeprecated(deltaDeprecated string) ApiRecordsGetRequest {
	r.deltaDeprecated = &deltaDeprecated
	return r
}

func (r ApiRecordsGetRequest) Execute() (*RecordsGet200Response, *http.Response, error) {
	return r.ApiService.RecordsGetExecute(r)
}

/*
RecordsGet Method for RecordsGet

Returns data synced with Nango Sync

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRecordsGetRequest
*/
func (a *DefaultAPIService) RecordsGet(ctx context.Context) ApiRecordsGetRequest {
	return ApiRecordsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RecordsGet200Response
func (a *DefaultAPIService) RecordsGetExecute(r ApiRecordsGetRequest) (*RecordsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RecordsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RecordsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/records"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.model == nil {
		return localVarReturnValue, nil, reportError("model is required and must be specified")
	}
	if r.connectionId == nil {
		return localVarReturnValue, nil, reportError("connectionId is required and must be specified")
	}
	if r.providerConfigKey == nil {
		return localVarReturnValue, nil, reportError("providerConfigKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "model", r.model, "")
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.modifiedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_after", r.modifiedAfter, "")
	}
	if r.deltaDeprecated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delta (deprecated)", r.deltaDeprecated, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Connection-Id", r.connectionId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Provider-Config-Key", r.providerConfigKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ConfigPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiScriptsConfigGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiScriptsConfigGetRequest) Execute() (*ScriptsConfigGet200Response, *http.Response, error) {
	return r.ApiService.ScriptsConfigGetExecute(r)
}

/*
ScriptsConfigGet Method for ScriptsConfigGet

Return the configuration for all integration scripts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiScriptsConfigGetRequest
*/
func (a *DefaultAPIService) ScriptsConfigGet(ctx context.Context) ApiScriptsConfigGetRequest {
	return ApiScriptsConfigGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ScriptsConfigGet200Response
func (a *DefaultAPIService) ScriptsConfigGetExecute(r ApiScriptsConfigGetRequest) (*ScriptsConfigGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ScriptsConfigGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ScriptsConfigGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scripts/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ConfigPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSyncPausePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	syncPausePostRequest *SyncPausePostRequest
}

func (r ApiSyncPausePostRequest) SyncPausePostRequest(syncPausePostRequest SyncPausePostRequest) ApiSyncPausePostRequest {
	r.syncPausePostRequest = &syncPausePostRequest
	return r
}

func (r ApiSyncPausePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPausePostExecute(r)
}

/*
SyncPausePost Method for SyncPausePost

Pauses the schedule of specified sync(s) for a given connection or all applicable connections if no connection is specified.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncPausePostRequest
*/
func (a *DefaultAPIService) SyncPausePost(ctx context.Context) ApiSyncPausePostRequest {
	return ApiSyncPausePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SyncPausePostExecute(r ApiSyncPausePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SyncPausePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sync/pause"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.syncPausePostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ConfigPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSyncRecordsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	model *string
	connectionId *string
	providerConfigKey *string
	delta *string
	limit *int32
	offset *int32
	sortBy *string
	order *string
	filter *string
}

// The data model to fetch
func (r ApiSyncRecordsGetRequest) Model(model string) ApiSyncRecordsGetRequest {
	r.model = &model
	return r
}

// The connection ID used to create the connection.
func (r ApiSyncRecordsGetRequest) ConnectionId(connectionId string) ApiSyncRecordsGetRequest {
	r.connectionId = &connectionId
	return r
}

// The integration ID used to create the connection (aka Unique Key).
func (r ApiSyncRecordsGetRequest) ProviderConfigKey(providerConfigKey string) ApiSyncRecordsGetRequest {
	r.providerConfigKey = &providerConfigKey
	return r
}

// Timestamp, e.g. 2023-05-31T11:46:13.390Z. If passed only records added or updated after this timestamp are returned, otherwise all records are returned.
func (r ApiSyncRecordsGetRequest) Delta(delta string) ApiSyncRecordsGetRequest {
	r.delta = &delta
	return r
}

// The maximum number of records to return. If not passed, all records are returned.
func (r ApiSyncRecordsGetRequest) Limit(limit int32) ApiSyncRecordsGetRequest {
	r.limit = &limit
	return r
}

// The number of records to skip. If not passed, no records are skipped.
func (r ApiSyncRecordsGetRequest) Offset(offset int32) ApiSyncRecordsGetRequest {
	r.offset = &offset
	return r
}

// Set how the records are sorted. The default is id. The options are &#39;created_at&#39;, &#39;updated_at&#39;, &#39;id&#39;.
func (r ApiSyncRecordsGetRequest) SortBy(sortBy string) ApiSyncRecordsGetRequest {
	r.sortBy = &sortBy
	return r
}

// Set the order of results. The default is &#39;desc&#39;. The options are &#39;desc&#39; or &#39;asc&#39;.
func (r ApiSyncRecordsGetRequest) Order(order string) ApiSyncRecordsGetRequest {
	r.order = &order
	return r
}

// Filter to only show results that have been added or updated or deleted. Helpful when used in conjuction with the delta parameter to retrieve a subset or records that were added, updated, or deleted with the latest sync.
func (r ApiSyncRecordsGetRequest) Filter(filter string) ApiSyncRecordsGetRequest {
	r.filter = &filter
	return r
}

func (r ApiSyncRecordsGetRequest) Execute() ([]SyncRecordsGet200ResponseInner, *http.Response, error) {
	return r.ApiService.SyncRecordsGetExecute(r)
}

/*
SyncRecordsGet Method for SyncRecordsGet

Returns data synced with Nango Sync

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncRecordsGetRequest
*/
func (a *DefaultAPIService) SyncRecordsGet(ctx context.Context) ApiSyncRecordsGetRequest {
	return ApiSyncRecordsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SyncRecordsGet200ResponseInner
func (a *DefaultAPIService) SyncRecordsGetExecute(r ApiSyncRecordsGetRequest) ([]SyncRecordsGet200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SyncRecordsGet200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SyncRecordsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sync/records"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.model == nil {
		return localVarReturnValue, nil, reportError("model is required and must be specified")
	}
	if r.connectionId == nil {
		return localVarReturnValue, nil, reportError("connectionId is required and must be specified")
	}
	if r.providerConfigKey == nil {
		return localVarReturnValue, nil, reportError("providerConfigKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "model", r.model, "")
	if r.delta != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delta", r.delta, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Connection-Id", r.connectionId, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Provider-Config-Key", r.providerConfigKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ConfigPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSyncStartPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	syncStartPostRequest *SyncStartPostRequest
}

func (r ApiSyncStartPostRequest) SyncStartPostRequest(syncStartPostRequest SyncStartPostRequest) ApiSyncStartPostRequest {
	r.syncStartPostRequest = &syncStartPostRequest
	return r
}

func (r ApiSyncStartPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncStartPostExecute(r)
}

/*
SyncStartPost Method for SyncStartPost

Starts the schedule of specified sync(s) for a given connection or all applicable connections if no connection is specified.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncStartPostRequest
*/
func (a *DefaultAPIService) SyncStartPost(ctx context.Context) ApiSyncStartPostRequest {
	return ApiSyncStartPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SyncStartPostExecute(r ApiSyncStartPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SyncStartPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sync/start"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.syncStartPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ConfigPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSyncStatusGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	providerConfigKey *string
	syncs *string
	connectionId *string
}

// The ID of the integration you established within Nango
func (r ApiSyncStatusGetRequest) ProviderConfigKey(providerConfigKey string) ApiSyncStatusGetRequest {
	r.providerConfigKey = &providerConfigKey
	return r
}

// The name of the syncs you want to fetch a status for. Pass in \&quot;*\&quot; to return all syncs per the integration
func (r ApiSyncStatusGetRequest) Syncs(syncs string) ApiSyncStatusGetRequest {
	r.syncs = &syncs
	return r
}

// The ID of the connection. If omitted, all connections will be surfaced.
func (r ApiSyncStatusGetRequest) ConnectionId(connectionId string) ApiSyncStatusGetRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiSyncStatusGetRequest) Execute() (*SyncStatusGet200Response, *http.Response, error) {
	return r.ApiService.SyncStatusGetExecute(r)
}

/*
SyncStatusGet Method for SyncStatusGet

Get the status of specified sync(s) (for a given connection or all applicable connections if no connection is specified)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncStatusGetRequest
*/
func (a *DefaultAPIService) SyncStatusGet(ctx context.Context) ApiSyncStatusGetRequest {
	return ApiSyncStatusGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SyncStatusGet200Response
func (a *DefaultAPIService) SyncStatusGetExecute(r ApiSyncStatusGetRequest) (*SyncStatusGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SyncStatusGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SyncStatusGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sync/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.providerConfigKey == nil {
		return localVarReturnValue, nil, reportError("providerConfigKey is required and must be specified")
	}
	if r.syncs == nil {
		return localVarReturnValue, nil, reportError("syncs is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "provider_config_key", r.providerConfigKey, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "syncs", r.syncs, "")
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connection_id", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ConfigPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSyncTriggerPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	syncTriggerPostRequest *SyncTriggerPostRequest
}

func (r ApiSyncTriggerPostRequest) SyncTriggerPostRequest(syncTriggerPostRequest SyncTriggerPostRequest) ApiSyncTriggerPostRequest {
	r.syncTriggerPostRequest = &syncTriggerPostRequest
	return r
}

func (r ApiSyncTriggerPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncTriggerPostExecute(r)
}

/*
SyncTriggerPost Method for SyncTriggerPost

Triggers an additional, one-off execution of specified sync(s) (for a given connection or all applicable connections if no connection is specified).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncTriggerPostRequest
*/
func (a *DefaultAPIService) SyncTriggerPost(ctx context.Context) ApiSyncTriggerPostRequest {
	return ApiSyncTriggerPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SyncTriggerPostExecute(r ApiSyncTriggerPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SyncTriggerPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sync/trigger"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.syncTriggerPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ConfigPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSyncUpdateConnectionFrequencyPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	syncUpdateConnectionFrequencyPutRequest *SyncUpdateConnectionFrequencyPutRequest
}

func (r ApiSyncUpdateConnectionFrequencyPutRequest) SyncUpdateConnectionFrequencyPutRequest(syncUpdateConnectionFrequencyPutRequest SyncUpdateConnectionFrequencyPutRequest) ApiSyncUpdateConnectionFrequencyPutRequest {
	r.syncUpdateConnectionFrequencyPutRequest = &syncUpdateConnectionFrequencyPutRequest
	return r
}

func (r ApiSyncUpdateConnectionFrequencyPutRequest) Execute() (*SyncUpdateConnectionFrequencyPut200Response, *http.Response, error) {
	return r.ApiService.SyncUpdateConnectionFrequencyPutExecute(r)
}

/*
SyncUpdateConnectionFrequencyPut Method for SyncUpdateConnectionFrequencyPut

Override a sync's default frequency for a specific connection, or revert to the default frequency.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncUpdateConnectionFrequencyPutRequest
*/
func (a *DefaultAPIService) SyncUpdateConnectionFrequencyPut(ctx context.Context) ApiSyncUpdateConnectionFrequencyPutRequest {
	return ApiSyncUpdateConnectionFrequencyPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SyncUpdateConnectionFrequencyPut200Response
func (a *DefaultAPIService) SyncUpdateConnectionFrequencyPutExecute(r ApiSyncUpdateConnectionFrequencyPutRequest) (*SyncUpdateConnectionFrequencyPut200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SyncUpdateConnectionFrequencyPut200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SyncUpdateConnectionFrequencyPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sync/update-connection-frequency"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.syncUpdateConnectionFrequencyPutRequest == nil {
		return localVarReturnValue, nil, reportError("syncUpdateConnectionFrequencyPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.syncUpdateConnectionFrequencyPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ConfigPut400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
